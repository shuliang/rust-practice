#+title: Hash Pipeline

Demo code from [[https://noz.ai/hash-pipeline/][High-throughput stream processing in Rust]].

* Single thread
[[file:hash-single/src/main.rs][src]]

#+name:hash-single.rs
#+begin_src rust :crates '((blake3 . 1.5.0)(sha2 . 0.10.8)) :tangle hash-single/src/main.rs :comments link :main no :eval no
use sha2::{Digest, Sha512};
use std::time::Instant;

const N: usize = 1_000_000_000;

fn main() {
    println!("hash-single start...");
    let start = Instant::now();
    for i in 0..N {
        let preimage = (i as u64).to_le_bytes();
        Sha512::digest(preimage);
        blake3::hash(&preimage);
    }
    println!("total time: {:?}", start.elapsed());
}
#+end_src

/Note: to save time, run it in "--release" mode, "--debug" mode takes hours./

#+begin_src sh :dir hash-single :results output :exports both
cargo run --release
#+end_src

#+RESULTS:
: hash-single start...
: total time: 214.70813464s

* Channels
[[file:hash-channel/src/main.rs][src]]

#+name: hash-channel.rs
#+begin_src rust :crates '((blake3 . 1.5.0)(sha2 . 0.10.8)) :tangle hash-channel/src/main.rs :main no :eval no
use sha2::{Digest, Sha512};
use std::sync::mpsc;
use std::thread;
use std::time::Instant;

const N: usize = 1_000_000_000;
const CHANNELS: usize = 1_000_000;

fn main() {
    println!("hash-channel start...");
    let start = Instant::now();

    let (generator_to_sha512_tx, generator_to_sha512_rx) = mpsc::sync_channel(CHANNELS);
    let (generator_to_blake3_tx, generator_to_blake3_rx) = mpsc::sync_channel(CHANNELS);
    let (sha512_to_result_tx, sha512_to_result_rx) = mpsc::sync_channel(CHANNELS);
    let (blake3_to_result_tx, blake3_to_result_rx) = mpsc::sync_channel(CHANNELS);

    // Generator
    thread::spawn(move || {
        for i in 0..N {
            let preimage = (i as u64).to_le_bytes();
            generator_to_sha512_tx.send(preimage).unwrap();
            generator_to_blake3_tx.send(preimage).unwrap();
        }
    });

    // Sha512
    thread::spawn(move || {
        while let Ok(preimage) = generator_to_sha512_rx.recv() {
            let hash = Sha512::digest(preimage);
            sha512_to_result_tx.send(hash).ok();
        }
    });

    // Blake3
    thread::spawn(move || {
        while let Ok(preimage) = generator_to_blake3_rx.recv() {
            let hash = blake3::hash(&preimage);
            blake3_to_result_tx.send(hash).ok();
        }
    });

    // Result
    let result_thread = thread::spawn(move || {
        for _ in 0..N {
            sha512_to_result_rx.recv().unwrap();
            blake3_to_result_rx.recv().unwrap();
        }
    });

    result_thread.join().unwrap();

    println!("total time: {:?}", start.elapsed());
}
#+end_src

#+begin_src sh :dir hash-channel :results output :exports both
cargo run --release
#+end_src

#+RESULTS:
: hash-channel start...
: total time: 529.111212211s

* Circular buffers
[[file:hash-circular/src/main.rs][src]]

#+name:hash-circular.rs
#+begin_src rust :crates '((blake3 . 1.5.0)(sha2 . 0.10.8)(rtrb . 0.2.3)) :tangle hash-circular/src/main.rs :comments link :main no :eval no
use rtrb::{Consumer, Producer, RingBuffer};
use sha2::{Digest, Sha512};
use std::thread;
use std::time::{Duration, Instant};

const N: usize = 1_000_000_000;
const CAPACITY: usize = 1_000_000;

fn main() {
    println!("hash-circular start...");
    let start = Instant::now();
    let (mut generator_to_sha512_tx, mut generator_to_sha512_rx) = RingBuffer::new(CAPACITY);
    let (mut generator_to_blake3_tx, mut generator_to_blake3_rx) = RingBuffer::new(CAPACITY);
    let (mut sha512_to_result_tx, mut sha512_to_result_rx) = RingBuffer::new(CAPACITY);
    let (mut blake3_to_result_tx, mut blake3_to_result_rx) = RingBuffer::new(CAPACITY);

    // Generator
    thread::spawn(move || {
        for i in 0..N {
            let preimage = (i as u64).to_le_bytes();
            push(&mut generator_to_sha512_tx, preimage);
            push(&mut generator_to_blake3_tx, preimage);
        }
    });

    // Sha512
    thread::spawn(move || loop {
        let preimage = pop(&mut generator_to_sha512_rx);
        let hash = Sha512::digest(preimage);
        push(&mut sha512_to_result_tx, hash);
    });

    // Blake3
    thread::spawn(move || loop {
        let preimage = pop(&mut generator_to_blake3_rx);
        let hash = blake3::hash(&preimage);
        push(&mut blake3_to_result_tx, hash);
    });

    // Result
    let result_thread = thread::spawn(move || {
        for _ in 0..N {
            pop(&mut sha512_to_result_rx);
            pop(&mut blake3_to_result_rx);
        }
    });

    result_thread.join().unwrap();

    println!("total time: {:?}", start.elapsed());
}

fn push<T>(tx: &mut Producer<T>, mut value: T) {
    loop {
        match tx.push(value) {
            Ok(_) => break,
            Err(rtrb::PushError::Full(v)) => value = v,
        }
        thread::sleep(Duration::from_millis(1));
    }
}

fn pop<T>(rx: &mut Consumer<T>) -> T {
    loop {
        if let Ok(value) = rx.pop() {
            return value;
        }
        thread::sleep(Duration::from_millis(1));
    }
}
#+end_src

** without thread sleep
/Comment "thread::sleep(Duration::from_millis(1))"./

#+begin_src sh :dir hash-circular :results output :exports both :eval no
cargo run --release
#+end_src

#+RESULTS:
: hash-circular start...
: total time: 259.291657468s

** with thread sleep
/Uncomment "thread::sleep(Duration::from_millis(1))"./

#+begin_src sh :dir hash-circular :results output :exports both
cargo run --release
#+end_src

#+RESULTS:
: hash-circular start...
: total time: 172.122766549s

* Single thread with only SHA512
/Comment "blake3::hash(&preimage);" in [[file:hash-single/src/main.rs][src]]./

#+begin_src sh :dir hash-single :results output :exports both
cargo run --release
#+end_src

#+RESULTS:
: hash-single start...
: total time: 163.528125573s

* Single thread with only blake3
/Comment "Sha512::digest(preimage);" in [[file:hash-single/src/main.rs][src]]./

#+begin_src sh :dir hash-single :results output :exports both
cargo run --release
#+end_src

#+RESULTS:
: hash-single start...
: total time: 53.694190896s

* More parallelization
[[file:hash-parallel/src/main.rs][src]]

#+name:hash-parallel.rs
#+begin_src rust :crates '((blake3 . 1.5.0)(sha2 . 0.10.8)(rtrb . 0.2.3)) :tangle hash-parallel/src/main.rs :comments link :main no :eval no
use rtrb::{Consumer, Producer};
use sha2::{Digest, Sha512};
use std::collections::VecDeque;
use std::thread;
use std::time::Duration;
use std::time::Instant;

const N: usize = 1_000_000_000;
const CAPACITY: usize = 1_000_000;

const NUM_SHA512_HASHERS: usize = 2;
const NUM_BLAKE3_HASHERS: usize = 2;

fn main() {
    println!("hash-parallel start...");
    let start = Instant::now();
    let (mut generator_to_sha512_tx, mut generator_to_sha512_rx) =
        ring_buffer(NUM_SHA512_HASHERS, CAPACITY);
    let (mut generator_to_blake3_tx, mut generator_to_blake3_rx) =
        ring_buffer(NUM_BLAKE3_HASHERS, CAPACITY);
    let (mut sha512_to_result_tx, mut sha512_to_result_rx) =
        ring_buffer(NUM_SHA512_HASHERS, CAPACITY);
    let (mut blake3_to_result_tx, mut blake3_to_result_rx) =
        ring_buffer(NUM_BLAKE3_HASHERS, CAPACITY);

    // Generator
    thread::spawn(move || {
        let mut sha512_channel = 0;
        let mut blake3_channel = 0;
        for i in 0..N {
            let preimage = (i as u64).to_le_bytes();
            push(&mut generator_to_sha512_tx[sha512_channel], preimage);
            push(&mut generator_to_blake3_tx[blake3_channel], preimage);
            sha512_channel = (sha512_channel + 1) % NUM_SHA512_HASHERS;
            blake3_channel = (blake3_channel + 1) % NUM_BLAKE3_HASHERS;
        }
    });

    // Sha512
    for _ in 0..NUM_SHA512_HASHERS {
        let mut rx = generator_to_sha512_rx.pop_front().unwrap();
        let mut tx = sha512_to_result_tx.pop_front().unwrap();
        thread::spawn(move || loop {
            let preimage = pop(&mut rx);
            let hash = Sha512::digest(preimage);
            push(&mut tx, hash);
        });
    }

    // Blake3
    for _ in 0..NUM_BLAKE3_HASHERS {
        let mut rx = generator_to_blake3_rx.pop_front().unwrap();
        let mut tx = blake3_to_result_tx.pop_front().unwrap();
        thread::spawn(move || loop {
            let preimage = pop(&mut rx);
            let hash = blake3::hash(&preimage);
            push(&mut tx, hash);
        });
    }

    // Result
    let result_thread = thread::spawn(move || {
        let mut sha512_channel = 0;
        let mut blake3_channel = 0;
        for _ in 0..N {
            pop(&mut sha512_to_result_rx[sha512_channel]);
            pop(&mut blake3_to_result_rx[blake3_channel]);
            sha512_channel = (sha512_channel + 1) % NUM_SHA512_HASHERS;
            blake3_channel = (blake3_channel + 1) % NUM_BLAKE3_HASHERS;
        }
    });

    result_thread.join().unwrap();

    println!("total time: {:?}", start.elapsed());
}

fn ring_buffer<T>(count: usize, capacity: usize) -> (VecDeque<Producer<T>>, VecDeque<Consumer<T>>) {
    (0..count).map(|_| rtrb::RingBuffer::new(capacity)).unzip()
}

fn push<T>(tx: &mut Producer<T>, mut value: T) {
    loop {
        match tx.push(value) {
            Ok(_) => break,
            Err(rtrb::PushError::Full(v)) => value = v,
        }
        thread::sleep(Duration::from_millis(1));
    }
}

fn pop<T>(rx: &mut Consumer<T>) -> T {
    loop {
        if let Ok(value) = rx.pop() {
            return value;
        }
        thread::sleep(Duration::from_millis(1));
    }
}
#+end_src

#+begin_src sh :dir hash-parallel :results output :exports both
cargo run --release
#+end_src

#+RESULTS:
: hash-parallel start...
: total time: 87.670414021s
